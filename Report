Oakley Katterheinrich
ECE 287 – Final Project Report
December 11, 2015
Brick Breaker
	The goal of this project was to recreate the game Breakout. The game involves a player moving a bar along the bottom of the screen, which deflects a moving ball back towards an arrangement of bricks. When the ball hits a brick, the brick disappears. The endgame being to destroy all the bricks. 
	The main problems to overcome are as follows: displaying to a monitor via VGA, changing the display through user input via FPGA, recognizing and reacting to displayed elements interacting (ball hitting brick/player bar), and finally honing the solutions to these problems into a reasonable and playable format. 
	I used the “fpga-pong” code (link in ‘Resources’ file) as the base for the VGA’s H_SYNC, V_SYNC, and clock modules so I could actually display onto the monitor. After using this code as a start, I scrapped the remaining parts and built the rest from the ground up. For every clock the fpga moves horizontally (left to right) across the monitor’s pixels, X being the x-coordinate and Y being the y-coordinate, assigning the current pixel with an RGB color value. Once X reaches the end of the display it resets back to the left (X=0) of the screen, and Y is incremented to start on the next line down. This is communicated to the monitor by sending sync pulses (h_sync, v_sync, hblank, clkLine) through the onboard VGA DAC, which converts digital inputs into analog for the monitor. This is all synced up by a PLL (from “fpga-pong”) which synchronizes the onboard clock (50MHz) with the monitor (60Hz). Without this the fpga would be sending inputs in different time windows than the monitor is expecting, so the display information wouldn’t be synced. 
	The main structure of my code starts by assigning 1-bit element variables based on the current X and Y values. These variables determined whether the current pixel is part of the element (the pixel displays the element). Among these variables are other 1-bit assign statements, which determines whether the ball has hit a brick or player bar. The always@(*) block uses these assign statements to decide what RGB color codes to select based on the element the current pixel is on. Before selecting a certain brick, the if statement checks to see if the brick is still “on.” The always@(posedge clk or negedge rst) block handles any movement on the screen, shifting the player bar left or right based on the player’s inputs (key0- right,  key1- left). It also moves the ball based on the current x and y direction. The ball changes direction whenever it hits another visible element. An exception being the player bar, where a hit on the left side of the bar sends the ball back to the left, and a hit on the right sends it right. This always block also sets a ‘brick##_is_kill’ variable when the brick is hit, therefore the brick disappears only after the ball has bounced off of it. There is a ‘color’ module that takes the RGB values assigned in the always@(*) block and assigns them to the VGA_R/G/B output. I used two different registers, the first being ‘Register’ for storing each row of bricks “kill status.” The values of which would change whenever the assign statements for a brick being hit would change; therefore, enabling write and inputting the status change. The second register ‘RegisterII’ was used for the scoreboard and would change whenever a brick is killed. The module below it just assigned the outputs for the 7-seg display according to the current score value. I also implemented a pause “button” (it’s a switch, but still) that freezes the current screen and will remain frozen until switched back. Other “buttons” include a restart option that creates a completely new game. The last being a new game option which allows the player to take a break between epic brick breaking marathons. The details of the FPGA inputs and scoring are listed below:

FPGA Input Legend:
(SW17) rst
(SW16) restart: hard restart that begins a new game regardless of win/loss status, game won’t start until switch it turned off
(SW15) player_pause: switch on for game to run/play, switch off to pause game
(SW14) player_new_game: on- new game will start immediately after a win/loss. I recommend leaving it off until a win/loss occurs then flip it on and off, but you do you. I am not responsible for any chronic finger cramps resulting from marathon brick breaking binges. 
(KEY1) player bar moves left
(KEY0) player bar moves right

Scoring: 
Scores are stored in a register, each row has it’s own register with specific inputs and outputs. Score is displayed on the 7-segment displays (HEX5 and HEX4)
Row0: red bricks, worth 3-points
Row1: green bricks, worth 2-points
Row2: blue bricks, worth 1-point
